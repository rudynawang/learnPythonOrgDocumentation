1)) Writing Modules

I didn't understood
No worries at all â€” this is very normal ğŸ™‚
Let me explain it in the simplest possible way, no fancy terms.

Think of your Python file as a TV remote

The code in the file is the buttons.
But the TV should turn on only when you press the power button, not when you just pick up the remote.

Now look at this line again:
if __name__ == '__main__':
    main()

What it is REALLY saying:

ğŸ‘‰ â€œOnly start the program if THIS file is the one being run.â€

Two situations (this is the key ğŸ”‘)
âœ… Situation 1: You run the file directly

You do:

python game.py


Python thinks:

â€œYes, this is the main file.â€

So it runs:

main()


âœ” Your program starts

âŒ Situation 2: The file is used by another file

Another file does:

import game


Python thinks:

â€œNo, this file is just being used, not run.â€

So it does NOT run:

main()


âœ” Only the functions are loaded, nothing starts automatically

One super-simple sentence (remember this):

ğŸ§  This line stops the program from running when the file is imported.

Tiny example (very clear)
file1.py
def hello():
    print("Hello")

if __name__ == '__main__':
    hello()

file2.py
import file1

What happens?

Run file1.py â†’ prints Hello

Run file2.py â†’ prints nothing

Why?
Because file1.py was imported, not run directly.


2)) then how the file2.py runs the file1.py functions 
Ahhh â€” this is the missing piece. Good question ğŸ‘
Letâ€™s clear it up very simply.

Key idea (most important line):

ğŸ‘‰ file2.py does NOT run file1.py automatically.
ğŸ‘‰ It only uses its functions when you call them.

Example again (simple)
file1.py
def hello():
    print("Hello")

if __name__ == '__main__':
    hello()

file2.py
import file1

file1.hello()

What happens step by step
1ï¸âƒ£ You run file2.py
python file2.py


Python:

Loads file1.py

Reads its functions

Does NOT run this part:

if __name__ == '__main__':
    hello()


Because file1.py is being imported, not run.

2ï¸âƒ£ How does hello() run then?

This line in file2.py:

file1.hello()


ğŸ‘‰ This explicitly calls the function.

So now:

Hello


is printed.

Very important rule to remember ğŸ§ 

import file1 â†’ loads the code

file1.hello() â†’ runs the function

Importing â‰  running

Real-life analogy ğŸ“¦

file1.py = a toolbox

file2.py = a worker

import file1 = opening the toolbox
file1.hello() = using a tool

One-line summary (crystal clear)

file2.py runs functions from file1.py only when it calls them using file1.function_name().


3.))  Importing module objects to the current namespace

main script's namespace means

First: what is a namespace?

A namespace is simply:

ğŸ‘‰ a place where names are stored and looked up

Names like:

variables

functions

classes

imported objects

Think of it as a dictionary of names â†’ objects.


What is the main script?

The main script is:
ğŸ‘‰ the Python file you are running directly

Example:
python game.py

Here, game.py is the main script.

So what does â€œmain scriptâ€™s namespaceâ€ mean?

It means:

ğŸ‘‰ all the names that are directly available inside the file you are running

Example without import
game.py
x = 10

def hello():
    print("Hi")


Here, the main scriptâ€™s namespace contains:

x

hello

You can use them directly:
hello()
print(x)

Example with module import
draw.py 
def draw_game():
    print("Drawing game")


game.py
from draw import draw_game

Now the main scriptâ€™s namespace contains:

draw_game

So you can write:
draw_game()

You do not need:
draw.draw_game()

Because draw_game is already in the main scriptâ€™s namespace.

Compare with this import
import draw

Now the main scriptâ€™s namespace contains:

draw

So you must write:
draw.draw_game()

One-line summary (remember this)

ğŸ§  The main scriptâ€™s namespace is the set of names you can use directly in the file that is being run.


4)) Module Initialization :

Module initialization The first time a module is loaded into a 
running Python script, it is initialized by executing the code in the 
module once. If another module in your code imports the same module 
again, it will not be loaded again, so local variables inside the 
module act as a "singleton," meaning they are initialized only once.

You can then use this to initialize objects. For example:

# draw.py

def draw_game():
    # when clearing the screen we can use the main screen object initialized in this module
    clear_screen(main_screen)
    ...

def clear_screen(screen):
    ...

class Screen():
    ...

# initialize main_screen as a singleton
main_screen = Screen()



Sure ğŸ™‚ Letâ€™s complete the example in a clear, runnable way to show how module initialization works like a singleton in Python.

draw.py

This module creates main_screen once, when it is first imported.

# draw.py

class Screen:
    def __init__(self):
        print("Screen initialized")

    def clear(self):
        print("Screen cleared")

    def draw(self):
        print("Drawing game objects")


def clear_screen(screen):
    screen.clear()


def draw_game():
    # uses the singleton screen created at import time
    clear_screen(main_screen)
    main_screen.draw()


# initialize main_screen as a singleton
main_screen = Screen()

game.py

This module imports draw.
Even if draw is imported multiple times, main_screen is created only once.

# game.py

import draw

def main():
    draw.draw_game()
    draw.draw_game()


if __name__ == "__main__":
    main()

Output
Screen initialized
Screen cleared
Drawing game objects
Screen cleared
Drawing game objects


ğŸ‘‰ Notice:

â€œScreen initializedâ€ prints only once

main_screen behaves like a singleton

All functions in draw.py share the same main_screen

Why this works

Python executes a module only the first time it is imported

The module object is cached in sys.modules

Variables at module level (like main_screen) persist for the programâ€™s lifetime

Bonus: proving itâ€™s the same object

Add this inside draw_game():

print(id(main_screen))


Youâ€™ll see the same ID every time, confirming itâ€™s the same instance.



5)) Extending module load path

There are a couple of ways to tell the 
Python interpreter where to look for modules, 
aside from the default local directory and 
built-in modules. You can use the environment 
variable PYTHONPATH to specify additional 
directories to look for modules like this:

PYTHONPATH=/foo python game.py

This executes game.py, and enables the script
 to load modules from the foo directory, 
 as well as the local directory.


 Sure â€” hereâ€™s a clearer, simpler explanation ğŸ‘‡

By default, Python looks for modules in:

The current directory (where your script is)

The built-in Python modules

A few standard library directories

If your module is somewhere else, you can tell Python where to look using the PYTHONPATH environment variable.

What PYTHONPATH does

PYTHONPATH is a list of extra directories that Python will search before running your program.

Example
PYTHONPATH=/foo python game.py


This command means:

Temporarily add the directory /foo to Pythonâ€™s module search path

Run game.py

Allow game.py to import modules that are located in /foo, in addition to:

the current directory

built-in and standard library modules

In plain English

â€œRun game.py, and while doing so, also look in /foo for any modules I try to import.â€

Important notes

This setting only applies to that single command

It does not permanently change your system

Useful for testing, projects with custom libraries, or multiple module locations
